import ElementUI from 'element-ui';
import { Submenu } from "element-ui";
const PopperJS = require("element-ui/lib/utils/popper.js");

function elementSetPropDefault(comp, prop, val) {
    let props = ElementUI[comp].props
    if (typeof (props[prop]) == 'function') {
        props[prop] = {
            type: props[prop],
            default: val,
        }
    } else {
        props[prop].default = val
    }
}
// elementSetPropDefault('TableColumn', 'align', 'center')
// elementSetPropDefault('TableColumn', 'headerAlign', 'center')

/**
 * Modifier used to add an offset to the popper, useful if you more granularity positioning your popper.
 * The offsets will shift the popper on the side of its reference element.
 * @method
 * @memberof Popper.modifiers
 * @argument {Object} data - The data object generated by _update method
 * @returns {Object} The data object, properly modified
 */
PopperJS.prototype.modifiers.offset = function (data) {
    var offset = this._options.offset;
    var popper = data.offsets.popper;

    function getOffset(offset) {
        if (typeof (offset) == 'number') {
            return { x: offset, y: 0 }
        } else if (Array.isArray(offset)) {
            return { x: offset[0], y: offset[1] }
        } else {
            return offset
        }
    }
    let tOffset = getOffset(offset)

    if (data.placement.indexOf('left') !== -1) {
        popper.top -= tOffset.x;
        popper.left -= tOffset.y;
    }
    else if (data.placement.indexOf('right') !== -1) {
        popper.top += tOffset.x;
        popper.left += tOffset.y;
    }
    else if (data.placement.indexOf('top') !== -1) {
        popper.left -= tOffset.x;
        popper.top -= tOffset.y;
    }
    else if (data.placement.indexOf('bottom') !== -1) {
        popper.left += tOffset.x;
        popper.top += tOffset.y;
    }
    return data;
};

/**
 * Modifier used to make sure the popper is always near its reference
 * @method
 * @memberof Popper.modifiers
 * @argument {Object} data - The data object generated by _update method
 * @returns {Object} The data object, properly modified
 */
PopperJS.prototype.modifiers.keepTogether = function (data) {
    var popper = getPopperClientRect(data.offsets.popper);
    var reference = data.offsets.reference;
    var f = Math.floor;

    // 限制弹窗在元素范围内
    // if (popper.right < f(reference.left)) {
    //     data.offsets.popper.left = f(reference.left) - popper.width;
    // }
    // if (popper.left > f(reference.right)) {
    //     data.offsets.popper.left = f(reference.right);
    // }
    // if (popper.bottom < f(reference.top)) {
    //     data.offsets.popper.top = f(reference.top) - popper.height;
    // }
    // if (popper.top > f(reference.bottom)) {
    //     data.offsets.popper.top = f(reference.bottom);
    // }

    return data;
};


/**
 * Given the popper offsets, generate an output similar to getBoundingClientRect
 * @function
 * @ignore
 * @argument {Object} popperOffsets
 * @returns {Object} ClientRect like output
 */
function getPopperClientRect(popperOffsets) {
    var offsets = Object.assign({}, popperOffsets);
    offsets.right = offsets.left + offsets.width;
    offsets.bottom = offsets.top + offsets.height;
    return offsets;
}


Submenu.methods.handleMouseenter = function(event, showTimeout = this.showTimeout) {

    if (!('ActiveXObject' in window) && event.type === 'focus' && !event.relatedTarget) {
      return;
    }
    const { rootMenu, disabled } = this;
    if (
      (rootMenu.menuTrigger === 'click' && rootMenu.mode === 'horizontal') ||
      (!rootMenu.collapse && rootMenu.mode === 'vertical') ||
      disabled
    ) {
      return;
    }
    this.dispatch('ElSubmenu', 'mouse-enter-child');
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => {
      this.rootMenu.openMenu(this.index, this.indexPath);
    }, showTimeout);

    if (this.appendToBody) {
        let pel = this.$parent.$el
        if(pel==this.$el){
            pel = this.$parent.$parent.$el
        }
        pel.dispatchEvent(new MouseEvent('mouseenter'));
    }
}
